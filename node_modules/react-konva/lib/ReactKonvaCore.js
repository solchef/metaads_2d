/**
 * Based on ReactArt.js
 * Copyright (c) 2017-present Lavrenov Anton.
 * All rights reserved.
 *
 * MIT
 */
'use strict';

exports.__esModule = true;
exports.useStrictMode = exports.Stage = exports.Transformer = exports.Shape = exports.Arrow = exports.RegularPolygon = exports.Path = exports.Tag = exports.Arc = exports.Ring = exports.Star = exports.TextPath = exports.Text = exports.Image = exports.Sprite = exports.Line = exports.Wedge = exports.Ellipse = exports.Circle = exports.Rect = exports.Label = exports.Group = exports.FastLayer = exports.Layer = exports.__matchRectVersion = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _Core = require('konva/lib/Core');

var _Core2 = _interopRequireDefault(_Core);

var _reactReconciler = require('react-reconciler');

var _reactReconciler2 = _interopRequireDefault(_reactReconciler);

var _ReactKonvaHostConfig = require('./ReactKonvaHostConfig');

var HostConfig = _interopRequireWildcard(_ReactKonvaHostConfig);

var _makeUpdates = require('./makeUpdates');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// export for testing
// const REACT_VERSION = '16.8.3';
// const __matchRectVersion = React.version === REACT_VERSION;
// skip version testing for now
var __matchRectVersion = exports.__matchRectVersion = true;

// That warning is useful, but I am not sure we really need it
// if (!__matchRectVersion) {
//   console.warn(
//     `Version mismatch detected for react-konva and react. react-konva expects to have react version ${REACT_VERSION}, but it has version ${
//       React.version
//     }. Make sure versions are matched, otherwise, react-konva work is not guaranteed. For releases information take a look here: https://github.com/konvajs/react-konva/releases`
//   );
// }

var StageWrap = function (_React$Component) {
  _inherits(StageWrap, _React$Component);

  function StageWrap() {
    _classCallCheck(this, StageWrap);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  StageWrap.prototype.componentDidMount = function componentDidMount() {
    if (!_Core2.default.isBrowser) {
      return;
    }
    this._stage = new _Core2.default.Stage({
      width: this.props.width,
      height: this.props.height,
      container: this._tagRef
    });

    this._setRef(this._stage);

    (0, _makeUpdates.applyNodeProps)(this._stage, this.props);

    this._mountNode = KonvaRenderer.createContainer(this._stage);
    KonvaRenderer.updateContainer(this.props.children, this._mountNode, this);
  };

  StageWrap.prototype._setRef = function _setRef(value) {
    var forwardedRef = this.props.forwardedRef;

    if (!forwardedRef) {
      return;
    }
    if (typeof forwardedRef === 'function') {
      forwardedRef(value);
    } else {
      forwardedRef.current = value;
    }
  };

  StageWrap.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (!_Core2.default.isBrowser) {
      return;
    }
    this._setRef(this._stage);
    (0, _makeUpdates.applyNodeProps)(this._stage, this.props, prevProps);

    KonvaRenderer.updateContainer(this.props.children, this._mountNode, this);
  };

  StageWrap.prototype.componentWillUnmount = function componentWillUnmount() {
    if (!_Core2.default.isBrowser) {
      return;
    }
    this._setRef(null);
    KonvaRenderer.updateContainer(null, this._mountNode, this);
    this._stage.destroy();
  };

  StageWrap.prototype.getStage = function getStage() {
    return this._stage;
  };

  StageWrap.prototype.render = function render() {
    var _this2 = this;

    var props = this.props;

    return _react2.default.createElement('div', {
      ref: function ref(_ref) {
        return _this2._tagRef = _ref;
      },
      accessKey: props.accessKey,
      className: props.className,
      role: props.role,
      style: props.style,
      tabIndex: props.tabIndex,
      title: props.title
    });
  };

  return StageWrap;
}(_react2.default.Component);

var Layer = exports.Layer = 'Layer';
var FastLayer = exports.FastLayer = 'FastLayer';
var Group = exports.Group = 'Group';
var Label = exports.Label = 'Label';
var Rect = exports.Rect = 'Rect';
var Circle = exports.Circle = 'Circle';
var Ellipse = exports.Ellipse = 'Ellipse';
var Wedge = exports.Wedge = 'Wedge';
var Line = exports.Line = 'Line';
var Sprite = exports.Sprite = 'Sprite';
var Image = exports.Image = 'Image';
var Text = exports.Text = 'Text';
var TextPath = exports.TextPath = 'TextPath';
var Star = exports.Star = 'Star';
var Ring = exports.Ring = 'Ring';
var Arc = exports.Arc = 'Arc';
var Tag = exports.Tag = 'Tag';
var Path = exports.Path = 'Path';
var RegularPolygon = exports.RegularPolygon = 'RegularPolygon';
var Arrow = exports.Arrow = 'Arrow';
var Shape = exports.Shape = 'Shape';
var Transformer = exports.Transformer = 'Transformer';

var KonvaRenderer = (0, _reactReconciler2.default)(HostConfig);

KonvaRenderer.injectIntoDevTools({
  findHostInstanceByFiber: function findHostInstanceByFiber() {
    return null;
  },
  bundleType: process.env.NODE_ENV !== 'production' ? 1 : 0,
  version: _react2.default.version,
  rendererPackageName: 'react-konva'
});

var Stage = exports.Stage = _react2.default.forwardRef(function (props, ref) {
  return _react2.default.createElement(StageWrap, _extends({}, props, { forwardedRef: ref }));
});

var useStrictMode = exports.useStrictMode = _makeUpdates.toggleStrictMode;